1. 들어가기 전에...
- 함수는 호출 시점이 중요하다! 순서대로 정의되지 않더라도 호출시 있으면 도출됨!
- 풀이 구성시 변수끼리, 함수끼리 나누어 구성하면 보기 편하담
- 어떤 함수가 return이 있는지 없는지는 함수 호출 후 원본이 변했는지 변하지 않았는지를 보면 된다. 변했다면 return이 없고, 변하지 않았다면 리턴이 있다.
- 다른 확인법으로는 해당 함수를 print해 보는 방법이 있다. print(변수명.함수())했을 때, None이라면 return이 없고, 어떤 값이 나오면 return이 있다!
- dict과 같은 구조는 안에 들어가는 내용을 적절하게 enter쳐주기
2. 함수의 기본 개념
- 함수는 정의 와 호출이 따로 있다
- 정의는 `def와 return`으로 이루어지게 되는데, return이 있어야 끝난다.
- return이 없는 경우도 있다. 이처럼 return이 명시되지 않는 경우에는 'None'이 출력된다. 
- 예시
  
  a = print(1)
  
  print(a)하면 뭐가 나올까?

  ----
  a. print(1) 함수가 호출
  
  b. 호출된 결과로 터미널에 1이 출력
  
  c. print(a) 함수가 호출
  
  d. 호출된 결과로 None을 뱉으면서 종료
  
- print() 함수는 return이 없는 함수다! (=return이 None이라는 의미)
  
3.  전역변수를 local에서 다루는 법
- local 함수 안에 `global 변수명`과 같이 쓴다. 
4.  built-in function
   1. `sum()`
   - 주어진 (list,tuple,range,set)의 `값`을 모두 더할 때 쓰는 함수
   - 값이니까 int가 아닌 str은 안됨~
   - **정해지지 않은 개수의 인자를 더할 때는 `*args`를 쓰면 된다**
   - ![Alt text](image.png)  
   1. `bool()`
   - `bool(변수명)`
   - (안에는 int, list 등 가능)
   - `bool(0)` 과 `bool([0])`은 같지 않다. 각각 F / T 도출됨
   1. `abs()`
   - 절댓값을 도출하는 함수
   1. `sorted()`
   - 오름차순 정렬. 원본은 바뀌지 않는 채, return값으로 정렬된 새로운 리스트가 나온다.
   - `변수명.sort()`도 오름차순 정렬하는 방식인데, 이 친구는 `return값이 없다. 즉, 원본 자체가 바뀌기 때문에` 오름차순 된 결과를 얻고 싶으면 `print(변수명)`을 호출하면 된다. 
   1. `sorted(변수명, reverse=True)`
   - 내림차순 정렬.
   1. `sep()`
   2. `reversed(seq)`
   3. `변수명.split()`
   - ()을 기준으로 나눈다. 공백이라면 str 공백을 기준으로, 다른 문자라면 해당 문자 전부를 기준으로 원본이 나뉘게 된다.

5. 인자
   
   1. 위치인자: 함수 호출 시 인자의 위치에 따라 전달되는 인자
   2. 기본인자: 함수 **정의**에서 매개변수에 기본 값을 할당하는 것
   3. 키워드 인자: 호출시 인자 이름과 함께 값을 전달하는 인자. 자리가 중요하지 않게 된다.
   4. 임의 인자: 개수가 정해지지 않은 인자를 처리. 앞에*를 붙여 사용한다.
   5. 임의의 키워드 인자: 정해지지 않은 개수의 키워드 인자를 처리하는 인자. 앞에 **를 붙여 사용한다. **kwargs 
6. 함수의 scope : LEGB 
7. 유용한 함수
   - `map(function, iterable)`
     - 예를 들어, list = [1, 2, 3]이 있고 `result = map(str, list)`라고 한다면 그 결과 모든 요소가 str이 된다. -> ['1', '2', '3']
   - `zip(*iterables)` 임의의 순회가능한 데이터구조를 모아 튜플을 원소로 하는 것으로 변환. zip에는 list나 dict, tuple이 가능하다. 
8. 칠칠
9.  팔팔